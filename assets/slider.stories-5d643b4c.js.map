{"version":3,"file":"slider.stories-5d643b4c.js","sources":["../../node_modules/.pnpm/framer-motion@7.6.12_react-dom@18.2.0_react@18.2.0/node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../packages/slider/src/style.ts","../../packages/slider/src/bar.tsx","../../packages/slider/src/content.ts","../../packages/slider/src/utils.ts","../../packages/slider/src/markBar.tsx","../../packages/slider/src/tick.tsx","../../packages/slider/src/useOffset.ts","../../packages/slider/src/NumTick.tsx","../../packages/slider/src/useElementSize.ts","../../packages/slider/src/slider.tsx"],"sourcesContent":["import { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.onChange(setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","import { getColor } from \"@illa-design/theme\"\nimport { css, SerializedStyles } from \"@emotion/react\"\nimport { SliderColorScheme } from \"./interface\"\n\nconst innerColor = [\n  \"white\",\n  \"blackAlpha\",\n  \"gray\",\n  \"red\",\n  \"orange\",\n  \"yellow\",\n  \"green\",\n  \"blue\",\n  \"cyan\",\n  \"purple\",\n  \"grayBlue\",\n  \"techPurple\",\n  \"techPink\",\n]\n\nexport function applyBgColor(\n  colorScheme: SliderColorScheme | undefined,\n  disabled: boolean,\n): string {\n  if (disabled) {\n    return `${getColor(\"gray\", \"08\")}`\n  } else if (!colorScheme) {\n    return `${getColor(\"blue\", \"03\")}`\n  } else if (innerColor.includes(colorScheme)) {\n    return `${getColor(colorScheme, \"03\")}`\n  } else {\n    return colorScheme\n  }\n}\n\nexport const applySliderWrapper = css`\n  width: 100%;\n  height: 40px;\n  box-sizing: content-box;\n  display: flex;\n  align-items: center;\n`\n\nexport function applySliderRoad(): SerializedStyles {\n  return css`\n    width: 100%;\n    height: 2px;\n    background-color: ${getColor(\"gray\", \"08\")};\n    border-radius: 2px;\n    display: flex;\n    align-items: center;\n    position: relative;\n  `\n}\nexport function applySliderBar(\n  disabled: boolean,\n  draggableBar: boolean,\n  width: number,\n  colorScheme?: SliderColorScheme,\n): SerializedStyles {\n  return css`\n    height: 2px;\n    position: absolute;\n    width: ${width}px;\n    background: ${applyBgColor(colorScheme, disabled)};\n    border-radius: 2px;\n    cursor: ${disabled || !draggableBar ? \"auto\" : \"pointer\"};\n  `\n}\nexport function applyMarkBar(\n  disabled: boolean,\n  colorScheme?: SliderColorScheme,\n): SerializedStyles {\n  return css`\n    box-sizing: border-box;\n    height: 12px;\n    width: 12px;\n    background-color: white;\n    border: 2px solid ${applyBgColor(colorScheme, disabled)};\n    border-radius: 50%;\n    position: absolute;\n    z-index: 2;\n    cursor: ${disabled ? \"auto\" : \"pointer\"};\n    transition: width 150ms ease-in-out, height 150ms ease-in-out;\n    &:hover {\n      height: 16px;\n      width: 16px;\n    }\n    &[data-location=\"right\"]:focus-within {\n      height: 16px;\n      width: 16px;\n    }\n  `\n}\nexport function applyBoundBar(\n  disabled: boolean,\n  isRightMark?: boolean,\n  colorScheme?: SliderColorScheme,\n): SerializedStyles {\n  return css`\n    box-sizing: border-box;\n    position: absolute;\n    left: ${isRightMark ? \"auto\" : 0}px;\n    right: ${isRightMark ? 0 : \"auto\"}px;\n    height: 8px;\n    width: 8px;\n    background-color: white;\n    border: 2px solid ${applyBgColor(colorScheme, disabled)};\n    border-radius: 50%;\n    z-index: 1;\n    transform: ${isRightMark ? \"translateX(50%)\" : \"translateX(-50%)\"};\n    cursor: ${disabled ? \"auto\" : \"pointer\"};\n  `\n}\n\nexport const applyBarContainer = css`\n  height: 100%;\n  width: 100%;\n`\n\nexport function applyTickContainer(\n  left: number,\n  disabled: boolean,\n): SerializedStyles {\n  return css`\n    height: 5px;\n    width: 8px;\n    position: absolute;\n    left: ${left}px;\n    bottom: 100%;\n    transform: translateX(-50%);\n    cursor: ${disabled ? \"auto\" : \"pointer\"};\n  `\n}\nexport function applyTick(background: string): SerializedStyles {\n  return css`\n    height: 5px;\n    width: 2px;\n    background: ${background};\n    position: absolute;\n    left: 50%;\n    transform: translateX(-50%);\n  `\n}\nexport function applyNumTick(\n  left: number,\n  disabled: boolean,\n): SerializedStyles {\n  return css`\n    height: 22px;\n    width: 15px;\n    position: absolute;\n    font-size: 14px;\n    margin-top: 4px;\n    line-height: 22px;\n    text-align: center;\n    color: ${getColor(\"gray\", \"02\")};\n    top: 100%;\n    left: ${left}px;\n    transform: translateX(-50%);\n    cursor: ${disabled ? \"auto\" : \"pointer\"};\n  `\n}\n","import { useEffect, useRef, forwardRef } from \"react\"\nimport { isObject } from \"@illa-design/system\"\nimport { applySliderBar } from \"./style\"\nimport { SliderBar } from \"./interface\"\nimport { motion, PanInfo, useMotionValue } from \"framer-motion\"\nexport const Bar = forwardRef<HTMLDivElement, SliderBar>((props, ref) => {\n  const {\n    isRange,\n    dragBar,\n    value,\n    left,\n    width,\n    disabled,\n    containerWidth,\n    partLength,\n    colorScheme,\n    onDragBarEnd,\n  } = props\n  const startValue = useRef<number[]>([])\n  const leftVal = useMotionValue(0)\n\n  const onDragStart = () => {\n    if (!isRange || (isObject(isRange) && !isRange.draggableBar)) return\n    startValue.current = value\n  }\n\n  const onDrag = (_: any, info: PanInfo) => {\n    if (!isRange || !(isObject(isRange) && isRange.draggableBar) || disabled)\n      return\n    const {\n      offset: { x },\n    } = info\n    dragBar(x, startValue.current)\n  }\n\n  const onDragEnd = (_: any, info: PanInfo) => {\n    if (!isRange || !(isObject(isRange) && isRange.draggableBar)) return\n    const {\n      offset: { x },\n    } = info\n    onDragBarEnd(x, startValue.current)\n  }\n\n  useEffect(() => {\n    leftVal.set(left)\n  }, [left, isRange, leftVal])\n  return (\n    <motion.div\n      drag={\n        !disabled && isObject(isRange) && isRange.draggableBar ? \"x\" : false\n      }\n      ref={ref}\n      onDragStart={onDragStart}\n      onDrag={onDrag}\n      onDragEnd={onDragEnd}\n      css={applySliderBar(\n        disabled,\n        isObject(isRange) && isRange.draggableBar,\n        width,\n        colorScheme,\n      )}\n      dragElastic={false}\n      dragConstraints={{ left: 0, right: containerWidth - width }}\n      style={{ x: leftVal }}\n      dragMomentum={false}\n      dragTransition={{\n        timeConstant: 200,\n        power: 0,\n        modifyTarget: (target) => Math.round(target / partLength) * partLength,\n      }}\n    />\n  )\n})\nBar.displayName = \"Bar\"\n","export const DefaultWidth = 240\nexport enum BarLocation {\n  LEFT = \"left\",\n  RIGHT = \"right\",\n}\n","import { BarLocation } from \"./content\"\n\nexport const formatValue = (val: string | number, step: number) => {\n  if (typeof val !== \"number\" && !val) return 0\n  if (typeof val === \"number\") return val\n  return Array.from(val.split(\",\"), (v) => {\n    if (getDecimalDigitsOrZero(step) !== 0) {\n      return processNumber(parseFloat(v), step)\n    }\n    return parseInt(v)\n  })\n}\n\nexport const getMarkBound = (\n  containerWidth: number,\n  value: number | number[],\n  location: BarLocation,\n  partLength: number,\n  max: number,\n  step: number,\n) => {\n  if (Array.isArray(value)) {\n    switch (location) {\n      default:\n      case BarLocation.RIGHT: {\n        return {\n          left: Math.round(value[0] / step + 1) * partLength - containerWidth,\n          right: Math.floor(max / step) * partLength - containerWidth,\n        }\n      }\n      case BarLocation.LEFT: {\n        return {\n          left: -containerWidth,\n          right: Math.floor((value[1] - step) / step) * partLength,\n        }\n      }\n    }\n  }\n  return {\n    left: -containerWidth,\n    right: Math.floor(max / step) * partLength,\n  }\n}\n\nexport const verifyRightValue = (\n  max: number,\n  min: number,\n  step: number,\n  rightVal: number,\n  leftVal: number | undefined,\n): number => {\n  if (rightVal >= max) return max\n  if (leftVal === undefined && rightVal <= min) {\n    return min\n  }\n  return rightVal\n}\nexport const verifyLeftValue = (\n  max: number,\n  min: number,\n  step: number,\n  rightVal: number,\n  leftVal: number | undefined,\n): undefined | number => {\n  if (leftVal === undefined) return leftVal\n  if (leftVal <= min) return min\n  if (leftVal >= max) return max\n  return leftVal\n}\n\nexport const verifyValue = (value: number | number[]) => {\n  if (Array.isArray(value)) {\n    return !value.every((v) => isNaN(v))\n  } else {\n    return !isNaN(value)\n  }\n}\n\nexport const getSafeStep = (step: number) => (step && step > 0 ? step : 1)\n\nexport const getDecimalDigitsOrZero = (num: number): number => {\n  if (Number.isInteger(num)) {\n    return 0\n  } else {\n    const numStr = num.toString()\n    const decimalIndex = numStr.indexOf(\".\")\n    return decimalIndex === -1 ? 0 : numStr.length - decimalIndex - 1\n  }\n}\n\nexport const processNumber = (num: number, step: number): number => {\n  const decimalDigits = getDecimalDigitsOrZero(step)\n  return decimalDigits === 0\n    ? Math.floor(num)\n    : parseFloat(num.toFixed(decimalDigits))\n}\n","import { forwardRef, useEffect, useRef } from \"react\"\nimport { applyMarkBar, applyBarContainer } from \"./style\"\nimport { SliderMarkBar } from \"./interface\"\nimport { motion, PanInfo, useMotionValue } from \"framer-motion\"\nimport { BarLocation } from \"./content\"\nimport { getMarkBound } from \"./utils\"\nimport useMeasure from \"react-use-measure\"\nimport { mergeRefs } from \"@illa-design/system\"\n\nexport const MarkBar = forwardRef<HTMLDivElement, SliderMarkBar>(\n  (props, ref) => {\n    const {\n      markBarRef,\n      isRange,\n      left,\n      right,\n      dragEnd,\n      value,\n      location,\n      disabled,\n      currentWidth,\n      step,\n      max,\n      partLength,\n      colorScheme,\n      drag,\n      mouseEnter,\n      mouseOut,\n      rerenderPosition,\n    } = props\n    const startValue = useRef<number | number[]>(0)\n    const rightVal = useMotionValue(0)\n    const [containerRef, rect] = useMeasure()\n\n    const onDragStart = () => {\n      if (disabled) return\n      startValue.current = value\n    }\n\n    const onDrag = (\n      _: MouseEvent | TouchEvent | PointerEvent,\n      info: PanInfo,\n    ) => {\n      if (disabled) return\n      const {\n        offset: { x },\n      } = info\n      drag(x - rect.width / 2, startValue.current, location)\n    }\n\n    const onDragEnd = (\n      _: MouseEvent | TouchEvent | PointerEvent,\n      info: PanInfo,\n    ) => {\n      if (disabled) return\n      const {\n        offset: { x },\n      } = info\n      dragEnd(x - rect.width / 2, startValue.current, location)\n    }\n    // The position needs to be verified after each update. Since the ball's motion boundary is controlled by itself, when the offset value remains unchanged, rightVal.set() will not be triggered.\n    useEffect(() => {\n      if (isRange) {\n        if (currentWidth && right !== -1 && location === BarLocation.RIGHT) {\n          if (rightVal.get() !== currentWidth - right - rect.width / 2) {\n            rightVal.set(currentWidth - right - rect.width / 2)\n            return\n          }\n        }\n        if (currentWidth && left !== -1 && location === BarLocation.LEFT) {\n          if (rightVal.get() !== left - rect.width / 2) {\n            rightVal.set(left - rect.width / 2)\n            return\n          }\n        }\n      } else {\n        if (rightVal.get() !== currentWidth - right - rect.width / 2) {\n          rightVal.set(currentWidth - right - rect.width / 2)\n          return\n        }\n      }\n    })\n\n    return (\n      <motion.div\n        drag=\"x\"\n        ref={mergeRefs(containerRef, markBarRef, ref)}\n        tabIndex={-1}\n        onDragStart={onDragStart}\n        onDrag={onDrag}\n        onDragEnd={onDragEnd}\n        onMouseDown={(e) => {\n          e.stopPropagation()\n        }}\n        onTouchStart={(e) => e.stopPropagation()}\n        onMouseDownCapture={(e) => e.stopPropagation()}\n        onTouchStartCapture={(e) => e.stopPropagation()}\n        onUpdate={() => {\n          rerenderPosition && rerenderPosition()\n        }}\n        data-location={location}\n        css={applyMarkBar(disabled, colorScheme)}\n        dragElastic={0}\n        dragConstraints={getMarkBound(\n          rect.width / 2,\n          value,\n          location,\n          partLength,\n          max,\n          step,\n        )}\n        style={{ x: rightVal, zIndex: 2 }}\n        dragMomentum={false}\n        dragTransition={{\n          timeConstant: 0,\n          power: 0,\n          modifyTarget: (target) =>\n            Math.round(target / partLength) * partLength - rect.width / 2,\n        }}\n      >\n        <div\n          css={applyBarContainer}\n          onMouseEnter={mouseEnter}\n          onMouseOut={mouseOut}\n        />\n      </motion.div>\n    )\n  },\n)\nMarkBar.displayName = \"MarkBar\"\n","import { FC } from \"react\"\nimport { SliderTick } from \"./interface\"\nimport { applyTick, applyTickContainer, applyBgColor } from \"./style\"\nexport const Tick: FC<SliderTick> = (props) => {\n  const {\n    left,\n    leftValue,\n    rightValue,\n    currentWidth,\n    disabled,\n    colorScheme,\n    value,\n  } = props\n  const rightBound = currentWidth - rightValue >= left\n  const background = applyBgColor(\n    colorScheme,\n    !(leftValue <= left && rightBound && !disabled),\n  )\n  return (\n    <div css={applyTickContainer(left, disabled)} data-value={value}>\n      <div css={applyTick(background)} />\n    </div>\n  )\n}\n","import { useState, useCallback, useMemo, useEffect } from \"react\"\nimport { BarLocation } from \"./content\"\nimport { IUseOffsetReturn } from \"./interface\"\nimport {\n  formatValue,\n  verifyRightValue,\n  verifyLeftValue,\n  processNumber,\n} from \"./utils\"\n\nexport const useOffset = (\n  min: number,\n  max: number,\n  step: number,\n): IUseOffsetReturn => {\n  const [leftOffset, setLeftOffset] = useState<number>(0)\n  const [rightOffset, setRightOffset] = useState<number>(-1)\n  const [barLength, setBarLength] = useState<number>(0)\n  const [currentValue, setCurrentValue] = useState<string | number>(\"\")\n  const [partLength, setPartLength] = useState<number>(0)\n  const [width, setWidth] = useState<number>(0)\n  const cacheValue = useMemo(() => {\n    return formatValue(currentValue, step)\n  }, [currentValue, step])\n\n  const getOffsetValueFromState = useCallback(\n    (rightVal: number, leftVal?: number) => {\n      let rightVerify = verifyRightValue(max, min, step, rightVal, leftVal)\n      let leftVerify = verifyLeftValue(max, min, step, rightVal, leftVal)\n      let leftValue, rightValue, barLength\n      if (leftVerify !== undefined) {\n        leftValue = Math.round(((leftVerify - min) / step) * partLength)\n        rightValue = Math.floor(((max - rightVerify) / step) * partLength)\n        barLength = Math.round(((rightVerify - leftVerify) / step) * partLength)\n      } else {\n        leftValue = 0\n        rightValue = Math.floor(((max - rightVerify) / step) * partLength)\n        barLength = width - rightValue\n      }\n      return [leftValue, rightValue, barLength]\n    },\n    [max, min, partLength, step, width],\n  )\n\n  const initOffsetFromState = useCallback(\n    (partLength: number, width: number, rightVal: number, leftVal?: number) => {\n      const [leftValue, rightValue, barLength] = getOffsetValueFromState(\n        rightVal,\n        leftVal,\n      )\n      setLeftOffset(leftValue)\n      setBarLength(barLength)\n      setRightOffset(rightValue)\n      setPartLength(partLength)\n      setCurrentValue(\n        leftVal !== undefined ? `${leftVal},${rightVal}` : rightVal,\n      )\n      setWidth(width)\n    },\n    [getOffsetValueFromState],\n  )\n\n  const onDragging = (\n    x: number,\n    startValue: number | number[],\n    location: BarLocation,\n  ) => {\n    if (Array.isArray(startValue)) {\n      onRangeDragging(x, startValue, location)\n    } else {\n      onSingleDragging(x, startValue)\n    }\n  }\n\n  const onSingleDragging = (x: number, startValue: number) => {\n    let leftBound = Math.floor((min - startValue) / step) * partLength,\n      rightBound = Math.floor((max - startValue) / step) * partLength,\n      val: number,\n      tempVal = Math.round(x / partLength) * partLength\n\n    if (tempVal >= rightBound) {\n      val = rightBound\n    } else if (tempVal <= leftBound) {\n      val = leftBound\n    } else {\n      val = tempVal\n    }\n    onSingleEnd(x, startValue)\n    setBarLength(Math.round((startValue - min) / step) * partLength + val)\n  }\n\n  const onRangeDragging = (\n    x: number,\n    startValue: number[],\n    location: string,\n  ) => {\n    let leftBound,\n      rightBound,\n      val: number,\n      tempVal = Math.round(x / partLength) * partLength\n    switch (location) {\n      case BarLocation.LEFT: {\n        leftBound = Math.floor((min - startValue[0]) / step) * partLength\n        rightBound =\n          Math.floor((startValue[1] - startValue[0] - step) / step) * partLength\n        if (tempVal >= rightBound) {\n          val = rightBound\n        } else if (tempVal <= leftBound) {\n          val = leftBound\n        } else {\n          val = tempVal\n        }\n        onRangeEnd(x, startValue, BarLocation.LEFT)\n        setBarLength(\n          Math.round((startValue[1] - startValue[0]) / step) * partLength - val,\n        )\n        break\n      }\n      default:\n      case BarLocation.RIGHT: {\n        leftBound =\n          Math.floor((startValue[0] - startValue[1] + step) / step) * partLength\n        rightBound = Math.floor((max - startValue[1]) / step) * partLength\n        if (tempVal >= rightBound) {\n          val = rightBound\n        } else if (tempVal <= leftBound) {\n          val = leftBound\n        } else val = tempVal\n        onRangeEnd(x, startValue, BarLocation.RIGHT)\n        setBarLength(\n          Math.round((startValue[1] - startValue[0]) / step) * partLength + val,\n        )\n        break\n      }\n    }\n  }\n\n  const onDragEnd = (\n    x: number,\n    startValue: number | number[],\n    location: BarLocation,\n    onAfterChange?: (v: number | number[]) => void,\n    onChange?: ((v: number | number[]) => void) | undefined,\n  ) => {\n    if (Array.isArray(startValue)) {\n      onRangeEnd(x, startValue, location, onAfterChange, onChange)\n    } else onSingleEnd(x, startValue, onAfterChange, onChange)\n  }\n\n  const onSingleEnd = (\n    x: number,\n    startValue: number,\n    onAfterChange?: (v: number) => void,\n    onChange?: ((v: number | number[]) => void) | undefined,\n  ) => {\n    let val = startValue + Math.round(x / partLength) * step,\n      currentVal,\n      currentMaxBound = Math.floor(max / step) * step\n    if (val >= currentMaxBound) {\n      currentVal = currentMaxBound\n    } else if (val <= min) {\n      currentVal = min\n    } else {\n      currentVal = val\n    }\n    const formatVal = processNumber(currentVal, step)\n    onAfterChange && onAfterChange(formatVal)\n    onChange && onChange(formatVal)\n    setCurrentValue(formatVal)\n    let [_, rightVal] = getOffsetValueFromState(currentVal)\n    setRightOffset(rightVal)\n  }\n\n  const onRangeEnd = (\n    x: number,\n    startValue: number[],\n    location: BarLocation,\n    onAfterChange?: (v: number[]) => void,\n    onChange?: ((v: number | number[]) => void) | undefined,\n  ) => {\n    let currentVal,\n      [leftValue, rightValue] = startValue\n    switch (location) {\n      case BarLocation.RIGHT:\n      default: {\n        let val = startValue[1] + Math.round(x / partLength) * step\n        if (val >= Math.floor(max / step) * step) {\n          currentVal = [leftValue, Math.floor(max / step) * step]\n        } else if (val <= leftValue + step) {\n          currentVal = [leftValue, leftValue + step]\n        } else {\n          currentVal = [leftValue, val]\n        }\n        break\n      }\n      case BarLocation.LEFT: {\n        let val = startValue[0] + Math.round(x / partLength) * step\n        if (rightValue - 1 <= val) {\n          currentVal = [rightValue - step, rightValue]\n        } else if (val <= min) {\n          currentVal = [min, Math.max(leftValue, rightValue)]\n        } else {\n          currentVal = [val, rightValue]\n        }\n        break\n      }\n    }\n    const formatVal = currentVal.map((v) => processNumber(v, step))\n    onAfterChange && onAfterChange(formatVal)\n    onChange && onChange(formatVal)\n    setCurrentValue(formatVal.join(\",\"))\n    let [leftVal, rightVal] = getOffsetValueFromState(\n      currentVal[1],\n      currentVal[0],\n    )\n    setLeftOffset(leftVal)\n    setRightOffset(rightVal)\n  }\n\n  const onDragBar = (x: number, startValue: number[]) => {\n    let leftBound = Math.round((min - startValue[0]) / step) * partLength,\n      rightBound = Math.floor((max - startValue[1]) / step) * partLength,\n      val: number,\n      tempVal = Math.round(x / partLength) * partLength\n    if (tempVal >= rightBound) {\n      val = rightBound\n    } else if (tempVal <= leftBound) {\n      val = leftBound\n    } else {\n      val = tempVal\n    }\n    setRightOffset(rightBound - val)\n    setLeftOffset(Math.round(startValue[0] / step) * partLength + val)\n  }\n\n  const onDragBarEnd = (\n    x: number,\n    startValue: number[],\n    onAfterChange?: (v: number[]) => void,\n  ) => {\n    const currentRangeVal = startValue.map((val, index) => {\n      const offset = val + Math.round(x / partLength) * step\n      if (index === 0) {\n        let bound = max - (startValue[1] - startValue[0])\n        if (offset <= min) return min\n        else if (offset >= bound) return bound\n        return offset\n      } else {\n        let bound = min + (startValue[1] - startValue[0])\n        if (offset <= bound) return bound\n        else if (offset >= max) return max\n        return offset\n      }\n    })\n    const formatVal = currentRangeVal.map((v) => processNumber(v, step))\n    onAfterChange && onAfterChange(formatVal)\n    setCurrentValue(formatVal.join(\",\"))\n  }\n\n  const onClickTick = (v: number) => {\n    if (Array.isArray(cacheValue)) {\n      let mid = Math.floor((cacheValue[1] - cacheValue[0]) / 2) + cacheValue[0]\n      if (v > mid) {\n        const [_, rightValue, barLength] = getOffsetValueFromState(\n          v,\n          cacheValue[0],\n        )\n        setCurrentValue(`${cacheValue[0]},${v}`)\n        setRightOffset(rightValue)\n        setBarLength(barLength)\n      } else {\n        const [leftValue, _, barLength] = getOffsetValueFromState(\n          cacheValue[1],\n          v,\n        )\n        setCurrentValue(`${v},${cacheValue[1]}`)\n        setLeftOffset(leftValue)\n        setBarLength(barLength)\n      }\n    } else {\n      const [leftValue, rightValue, barLength] = getOffsetValueFromState(v)\n      setCurrentValue(v)\n      setLeftOffset(leftValue)\n      setBarLength(barLength)\n      setRightOffset(rightValue)\n    }\n  }\n\n  return {\n    currentValue: cacheValue,\n    leftOffset,\n    rightOffset,\n    barLength,\n    partLength,\n    initOffsetFromState,\n    onDragging,\n    onDragEnd,\n    onClickTick,\n    onDragBar,\n    onDragBarEnd,\n  }\n}\n","import { FC } from \"react\"\nimport { SliderNumTick } from \"./interface\"\nimport { applyNumTick } from \"./style\"\nexport const NumTick: FC<SliderNumTick> = (props) => {\n  const { left, disabled, value } = props\n\n  return (\n    <div css={applyNumTick(left, disabled)} data-value={value}>\n      {value}\n    </div>\n  )\n}\n","import { useEffect, useState } from \"react\"\n\nexport const useElementSize = (\n  ref: React.MutableRefObject<HTMLDivElement | null>,\n) => {\n  const [width, setWidth] = useState(0)\n\n  useEffect(() => {\n    if (ref.current) {\n      const observer = new ResizeObserver((entries) => {\n        const { width } = entries[0].contentRect\n        setWidth(width)\n      })\n      observer.observe(ref.current)\n      return () => {\n        if (ref.current) {\n          observer.unobserve(ref.current)\n        }\n      }\n    }\n  }, [ref])\n\n  return width\n}\n","import {\n  useEffect,\n  useRef,\n  useState,\n  forwardRef,\n  useMemo,\n  MouseEvent,\n  useImperativeHandle,\n  useCallback,\n} from \"react\"\nimport { Bar } from \"./bar\"\nimport { MarkBar } from \"./markBar\"\nimport { Tick } from \"./tick\"\nimport { applySliderWrapper, applySliderRoad, applyBoundBar } from \"./style\"\nimport { applyBoxStyle } from \"@illa-design/theme\"\nimport { Trigger, TriggerRefHandler } from \"@illa-design/trigger\"\nimport { SliderProps, ICustomRef } from \"./interface\"\nimport { DefaultWidth, BarLocation } from \"./content\"\nimport { useOffset } from \"./useOffset\"\nimport { getSafeStep, processNumber, verifyValue } from \"./utils\"\nimport { NumTick } from \"./NumTick\"\nimport { useElementSize } from \"./useElementSize\"\n\nexport const Slider = forwardRef<ICustomRef, SliderProps>((props, ref) => {\n  const {\n    disabled = false,\n    tooltipVisible = true,\n    showTicks = false,\n    hideValue = false,\n    max = 10,\n    min = 0,\n    step = 1,\n    tooltipPosition = \"top\",\n    defaultValue = 0,\n    value = defaultValue,\n    isRange = Array.isArray(value),\n    startMarkShow = false,\n    endMarkShow = false,\n    colorScheme,\n    formatTooltip = (v) => v,\n    onAfterChange,\n    onChange,\n  } = props\n  const [currentWidth, setCurrentWidth] = useState(DefaultWidth)\n  const currentRef = useRef<HTMLDivElement>(null)\n  const markBarRef = useRef<HTMLDivElement>(null)\n\n  const [partNumber, setPartNumber] = useState<number | undefined>(undefined)\n  const roadRef = useRef<HTMLDivElement | null>(null)\n  const rightTriggerRef = useRef<TriggerRefHandler | undefined>()\n  const leftTriggerRef = useRef<TriggerRefHandler | undefined>()\n  const [rightTriggerShow, setRightTriggerShow] = useState(false)\n  const [leftTriggerShow, setLeftTriggerShow] = useState(false)\n  const leftValue = useMemo(() => {\n    return Array.isArray(value) ? value[0] : undefined\n  }, [value])\n  const rightValue = useMemo(() => {\n    return Array.isArray(value) ? value[1] : value\n  }, [value])\n  const {\n    currentValue,\n    leftOffset,\n    rightOffset,\n    barLength,\n    partLength,\n    initOffsetFromState,\n    onDragging,\n    onDragEnd,\n    onClickTick,\n    onDragBar,\n    onDragBarEnd,\n  } = useOffset(min, max, getSafeStep(step))\n\n  const width = useElementSize(currentRef)\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      setRightTriggerShow(true)\n      markBarRef.current?.focus()\n    },\n  }))\n\n  const dragging = (\n    x: number,\n    startValue: number | number[],\n    location: BarLocation,\n  ) => {\n    onDragging(x, startValue, location)\n  }\n\n  const dragEnd = (\n    x: number,\n    startValue: number | number[],\n    location: BarLocation,\n  ) => {\n    markBarRef.current?.blur()\n    onDragEnd(x, startValue, location, onAfterChange, onChange)\n  }\n\n  const dragBar = (x: number, startValue: number[]) => {\n    onDragBar(x, startValue)\n  }\n  const dragBarEnd = (x: number, startValue: number[]) => {\n    onDragBarEnd(x, startValue, onAfterChange)\n  }\n\n  const tickClick = (e: MouseEvent<HTMLElement>) => {\n    const { target } = e\n    if (target) {\n      const { dataset } = target as HTMLElement\n      if (dataset && dataset.value !== undefined) {\n        onClickTick(parseFloat(dataset.value))\n        return\n      }\n      const { parentElement } = target as HTMLElement\n      const parentDataset = parentElement?.dataset\n      if (parentElement && parentDataset && parentDataset.value !== undefined) {\n        onClickTick(parseFloat(parentDataset.value))\n      }\n    }\n  }\n\n  const rightRerenderPosition = useCallback(() => {\n    rightTriggerRef && rightTriggerRef.current?.rerenderPosition()\n  }, [])\n\n  const leftRerenderPosition = useCallback(() => {\n    leftTriggerRef && leftTriggerRef.current?.rerenderPosition()\n  }, [])\n\n  useEffect(() => {\n    if (roadRef.current) {\n      const safeStep = getSafeStep(step)\n      const partNum = Math.ceil((max - min) / safeStep)\n      const partLength = width / ((max - min) / safeStep)\n      setPartNumber(partNum)\n      setCurrentWidth(width)\n      initOffsetFromState(partLength, width, rightValue, leftValue)\n    }\n  }, [\n    isRange,\n    max,\n    min,\n    step,\n    initOffsetFromState,\n    leftValue,\n    rightValue,\n    width,\n  ])\n  return (\n    <div ref={currentRef} css={[applySliderWrapper, applyBoxStyle(props)]}>\n      <div css={applySliderRoad()} ref={roadRef} onClick={tickClick}>\n        {showTicks &&\n          partNumber &&\n          partNumber > 0 &&\n          [...new Array(partNumber - 1)].map((_, i) => (\n            <Tick\n              key={i}\n              value={processNumber((i + 1) * step, step)}\n              left={(i + 1) * partLength}\n              leftValue={leftOffset}\n              rightValue={rightOffset}\n              currentWidth={currentWidth}\n              colorScheme={colorScheme}\n              disabled={disabled}\n            />\n          ))}\n        {showTicks &&\n          partNumber &&\n          partNumber > 0 &&\n          [...new Array(partNumber + 1)].map(\n            (_, i) =>\n              i <= Math.floor((max - min) / step) && (\n                <NumTick\n                  key={i}\n                  value={processNumber(min + i * step, step)}\n                  left={i * partLength}\n                  disabled={disabled}\n                />\n              ),\n          )}\n        {startMarkShow && (\n          <div\n            css={applyBoundBar(disabled, false)}\n            onClick={() => onClickTick(min)}\n          />\n        )}\n        {Boolean(isRange) && (\n          <Trigger\n            content={\n              Array.isArray(currentValue)\n                ? formatTooltip(currentValue[0])\n                : formatTooltip(currentValue)\n            }\n            position={tooltipPosition}\n            triggerRef={leftTriggerRef}\n            popupVisible={leftTriggerShow && tooltipVisible}\n          >\n            <MarkBar\n              isRange={isRange}\n              left={leftOffset}\n              right={-1}\n              drag={dragging}\n              dragEnd={dragEnd}\n              value={currentValue}\n              location={BarLocation.LEFT}\n              disabled={disabled}\n              max={max}\n              min={min}\n              step={step}\n              currentWidth={currentWidth}\n              partLength={partLength}\n              colorScheme={colorScheme}\n              mouseEnter={() => setLeftTriggerShow(true)}\n              mouseOut={() => setLeftTriggerShow(false)}\n              rerenderPosition={leftRerenderPosition}\n            />\n          </Trigger>\n        )}\n        <Trigger\n          content={\n            Array.isArray(currentValue)\n              ? formatTooltip(currentValue[1])\n              : formatTooltip(currentValue)\n          }\n          triggerRef={rightTriggerRef}\n          position={tooltipPosition}\n          popupVisible={rightTriggerShow && tooltipVisible}\n        >\n          <MarkBar\n            right={rightOffset}\n            left={-1}\n            isRange={isRange}\n            drag={dragging}\n            dragEnd={dragEnd}\n            markBarRef={markBarRef}\n            value={currentValue}\n            max={max}\n            min={min}\n            step={step}\n            location={BarLocation.RIGHT}\n            disabled={disabled}\n            currentWidth={currentWidth}\n            partLength={partLength}\n            colorScheme={colorScheme}\n            mouseEnter={() => setRightTriggerShow(true)}\n            mouseOut={() => setRightTriggerShow(false)}\n            rerenderPosition={rightRerenderPosition}\n          />\n        </Trigger>\n        {endMarkShow && (\n          <div\n            css={applyBoundBar(disabled, true)}\n            onClick={() => onClickTick(max)}\n          />\n        )}\n        <Bar\n          width={barLength}\n          left={leftOffset}\n          isRange={isRange}\n          value={currentValue as number[]}\n          dragBar={dragBar}\n          disabled={disabled}\n          colorScheme={colorScheme}\n          containerWidth={currentWidth}\n          partLength={partLength}\n          onDragBarEnd={dragBarEnd}\n        />\n      </div>\n    </div>\n  )\n})\n\nSlider.displayName = \"Slider\"\n"],"names":["useMotionValue","initial","value","useConstant","motionValue","isStatic","useContext","MotionConfigContext","setLatest","useState","useEffect","innerColor","applyBgColor","colorScheme","disabled","getColor","applySliderWrapper","css","applySliderRoad","applySliderBar","draggableBar","width","applyMarkBar","applyBoundBar","isRightMark","applyBarContainer","applyTickContainer","left","applyTick","background","applyNumTick","Bar","forwardRef","props","ref","isRange","dragBar","containerWidth","partLength","onDragBarEnd","startValue","useRef","leftVal","onDragStart","isObject","onDrag","_","info","x","onDragEnd","jsx","motion","target","DefaultWidth","BarLocation","formatValue","val","step","v","getDecimalDigitsOrZero","processNumber","getMarkBound","location","max","verifyRightValue","min","rightVal","verifyLeftValue","getSafeStep","num","numStr","decimalIndex","decimalDigits","MarkBar","markBarRef","right","dragEnd","currentWidth","drag","mouseEnter","mouseOut","rerenderPosition","containerRef","rect","useMeasure","mergeRefs","e","Tick","leftValue","rightValue","rightBound","useOffset","leftOffset","setLeftOffset","rightOffset","setRightOffset","barLength","setBarLength","currentValue","setCurrentValue","setPartLength","setWidth","cacheValue","useMemo","getOffsetValueFromState","useCallback","rightVerify","leftVerify","initOffsetFromState","onDragging","onRangeDragging","onSingleDragging","leftBound","tempVal","onSingleEnd","onRangeEnd","onAfterChange","onChange","currentVal","currentMaxBound","formatVal","mid","index","offset","bound","NumTick","useElementSize","observer","entries","Slider","tooltipVisible","showTicks","hideValue","tooltipPosition","defaultValue","startMarkShow","endMarkShow","formatTooltip","setCurrentWidth","currentRef","partNumber","setPartNumber","roadRef","rightTriggerRef","leftTriggerRef","rightTriggerShow","setRightTriggerShow","leftTriggerShow","setLeftTriggerShow","onClickTick","onDragBar","useImperativeHandle","_a","dragging","dragBarEnd","tickClick","dataset","parentElement","parentDataset","rightRerenderPosition","leftRerenderPosition","safeStep","partNum","partLength2","applyBoxStyle","jsxs","i","Trigger"],"mappings":"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","x_google_ignoreList":[0]}